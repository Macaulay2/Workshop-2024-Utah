loadPackage ("NumberFields", Reload=>true)

-- Tests simpleExt

R1 = QQ[x,z]/(x^2+1,z^2-2)
use R1
f1 = x
minimalPolynomial f1
NF1 = numberField R1
ring NF1
SE1 = simpleExt NF1
ring SE1

R1 = QQ[x,y,z]/(x^2+1,y^2-2,z^3-2)
NF1 = numberField R1
ring NF1
degree NF1
gens NF1
SE1 = simpleExt NF1
ring SE1

-- Tests splittingField

polynomialSplits = f1 -> (
    L1 = decompose ideal f1;
    splits = true;
    for i from 0 to #L1-1 do (
        currentEntry := (entries gens L1#i)#0;
        if not (length(currentEntry)==1 and max(degree(currentEntry#0))==1) then (splits = false; break;)
    );
    splits
)

R1 = QQ[x]
f1 = x^3-2
L1 = decompose ideal f1 -- Doesn't split completely since not all ideals are generated by a degree one polynomial
polynomialSplits f1 -- Confirmation
S1 = target splittingField f1 -- Create the splitting field
f11 = (map((ring S1)[y], R1, {y})) f1
L2 = decompose ideal f11
polynomialSplits f11

ring S1

-- Tests field automorphisms

R = QQ[x]/(x^2-2) -- Q(sqrt(2))
isGalois(numberField R) -- Just to confirm that R is Galois (since degree is 2 and automorphism group has size 2)
sigma = matrix({{1, 0}, {0, 1}}) -- Identity map
sigmaTargets = (entries(matrix({prepend(1, gens R)})*sigma))#0 -- Create a list consisting of elements of R that the basis elements of R go to under left multiplcation by sigma
phi = map(R, R, drop(sigmaTargets, 1)) -- Create a RingMap sending the generators of R to their corresponding sigmaTargets elements. We drop the first element of sigmaTargets because that is where the element 1_R goes
isWellDefined phi
isInjective phi


phi = map(R, R, {-x}) -- Valid automorphism
isWellDefined(phi) -- Checks that above is a valid ring map
isInjective(phi) -- Checks that above is injective
--isSurjective(phi) -- Warning: can't apply isSurjective to RingMap

isWellDefined(map(R, R, {2*x})) -- Invalid automorphism

-- pushFwd way to test field automorphisms

R = QQ[x,y]/(x^2+1,y^2-2)
sigma = matrix({{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}})
phi = map(R, R, {x,y})
f = pushFwd phi
g = f#2
h = pushFwd(phi, sigma)

-- Functions to test field automorphisms

-- Method built from lines above
--isFieldAutomorphism = (NF1, sigma1) -> (
--    phi1 = ringMapFromMatrix(NF1, sigma1);
--    if not isWellDefined phi1 then return false;
--    if not isInjective phi1 then return false;
--    return true
--)

loadPackage ("NumberFields", Reload=>true)

isFieldAutomorphism = (NF1, sigma1) -> (
    R1 = ring NF1;
    C1 = coefficientRing R1;
    P1 = (pushFwd(map(R1, C1)))#2;
    phi1 = ringMapFromMatrix(NF1, sigma1);
    newBasis1 = apply(basis NF1, i -> phi1(i));
    newGensAsBasis1 = apply(newBasis1, P1);
    A = newGensAsBasis1#0;
    for i from 1 to #newGensAsBasis1-1 do (
        A |= newGensAsBasis1#i;
    );
    return (A-sigma1)==0 -- Test matrix equality only on entry level; A==sigma1 would return false if either sources or target differ
)

-- Helper method for isFieldAutomorphism
ringMapFromMatrix = (NF1, sigma1) -> (
    R1 = ring NF1;
    C1 = coefficientRing R1;
    P1 = (pushFwd(map(R1, C1)))#2;
    gensAsBasis1 = apply(gens R1, P1); -- Expresses each generator of R1 as a vector w.r.t. the basis of NF1
    newGensAsBasis1 = apply(gensAsBasis1, i -> sigma1*i);
    newGensAsMatrices1 = apply(newGensAsBasis1, i -> matrix({basis NF1})*i);
    newGens1 = apply(newGensAsMatrices1, i -> (entries i)#0#0);
    map(R1, R1, newGens1)
)



R = QQ[x,y]/(x^2+1,y^2-2)
NF = numberField R

-- Example 1
sigma = matrix({{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}})**QQ -- Identity matrix corresponds to identity map
phi = ringMapFromMatrix(NF, sigma)
for i from 1 to #(gens ring NF) do (
    a_i = (gens ring NF)#(i-1)
)
phi(a_1) -- Should return a_1
phi(a_2) -- Should return a_2
phi(a_1*a_2) -- Should return a_1*a_2
isFieldAutomorphism(NF, sigma) -- Should return true

-- Example 2
sigma = matrix({{1,0,0,0},{0,-1,0,0},{0,0,1,0},{0,0,0,-1}})**QQ -- Matrix corresponds to sending i to -i and sending sqrt(2) to -sqrt(2)
phi = ringMapFromMatrix(NF, sigma)
for i from 1 to #(gens ring NF) do (
    a_i = (gens ring NF)#(i-1)
)
phi(a_1) -- Should return -a_1
phi(a_2) -- Should return -a_2
phi(a_1*a_2) -- Should return a_1*a_2
isFieldAutomorphism(NF, sigma) -- Should return true

-- Example 3
sigma = matrix({{1,0,0,0},{0,-1,0,0},{0,0,-1,0},{0,0,0,-1}})**QQ -- Invalid map
phi = ringMapFromMatrix(NF, sigma)
for i from 1 to #(gens ring NF) do (
    a_i = (gens ring NF)#(i-1)
)
phi(a_1) -- Should return -a_1
phi(a_2) -- Should return -a_2
phi(a_1*a_2) -- Should return a_1*a_2; note that actual map corresponding to sigma returns -a_1*a_2
isFieldAutomorphism(NF, sigma) -- Should return false

-- Example 4: Q(i)
R = QQ[x]/(x^2+1)
NF = numberField R

sigma = matrix({{1,0},{0,1}})**QQ -- Identity matrix corresponds to identity map
phi = ringMapFromMatrix(NF, sigma)
for i from 1 to #(gens ring NF) do (
    a_i = (gens ring NF)#(i-1)
)
phi(a_1) -- Should return a_1
isFieldAutomorphism(NF, sigma) -- Should return true

-- Example 5
sigma = matrix({{1,0},{0,-1}}) -- Matrix corresponding to complex conjugation, the only nontrivial field automorphism
phi = ringMapFromMatrix(NF, sigma)
for i from 1 to #(gens ring NF) do (
    a_i = (gens ring NF)#(i-1)
)
phi(a_1) -- Should return a_1
isFieldAutomorphism(NF, sigma) -- Should return true

-- Example 6
loadPackage ("NumberFields", Reload=>true)
R = QQ[x]/(x^2+1)
NF = numberField R
sigmaI = matrix({{1,0},{0,1}})**QQ
ringMapFromMatrix(NF, sigmaI)
isFieldAutomorphism(NF, sigmaI) -- Should return true
sigmaConj = matrix({{1,0},{0,-1}})**QQ
ringMapFromMatrix(NF, sigmaConj)
isFieldAutomorphism(NF, sigmaConj) -- Should return true
sigma = matrix({{-1,0},{0,1}})**QQ
ringMapFromMatrix(NF, sigma)
isFieldAutomorphism(NF, sigma) -- Should return false
sigma = matrix({{1,0},{0,2}})**QQ
ringMapFromMatrix(NF, sigma)
isFieldAutomorphism(NF, sigma) -- Should return false
sigma = matrix({{1,0},{0,0}})**QQ
ringMapFromMatrix(NF, sigma)
isFieldAutomorphism(NF, sigma) -- Should return false
-- The above two matrices should be on the only automorphisms of Q(i). Let's generate a bunch of random matrices and ensure they aren't automorphisms
valid = true;
for i from 1 to 1000 do (
    sigma = random(QQ^2, QQ^2);
    if isFieldAutomorphism(NF, sigma) then (
        if (sigma-sigmaI!=0 and sigma-sigmaConj!=0) then (
            print sigma;
            valid = false;
        );
    );
);
valid -- Returns true if all 1000 random matrices above do not produce automorphisms

-- Example 7
-- Let's repeat example 6 for Q(cube root of 2). This field only has the trivial automorphism
R = QQ[x]/(x^3-2)
NF = numberField R

sigmaI = matrix({{1,0,0},{0,1,0},{0,0,1}})
ringMapFromMatrix(NF, sigmaI)
isFieldAutomorphism(NF, sigmaI) -- Should return true
sigma2 = matrix({{1,0,0},{0,0,1},{0,1,0}})
ringMapFromMatrix(NF, sigma2)
isFieldAutomorphism(NF, sigma2) -- Should return false
valid = true;
for i from 1 to 1000 do (
    sigma = random(QQ^3, QQ^3);
    if isFieldAutomorphism(NF, sigma) then (
        if sigma-sigmaI!=0 then (
            print sigma;
            valid = false;
        );
    );
);
valid -- Returns true if all 1000 random matrices above do not produce automorphisms

